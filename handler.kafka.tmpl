// Code generated by protoc-gen-go-kafka. DO NOT EDIT.
//
// versions:
//     protoc-gen-go-kafka {{.Version}}
//     protoc        (unknown)
// source: {{.PathFile}}

package {{ .PackageName }}

import (
	"context"

	"github.com/ThreeDotsLabs/watermill/message"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"google.golang.org/protobuf/encoding/protojson"
)

// {{.ModelName}}Event структурая, содержащая поля сообщения
type {{.ModelName}}Event struct {
	ID   string
	Meta map[string]string
	Body *{{.ModelName}}
}

// New{{.ModelName}}Event конструктор события {{.ModelName}}Event
func New{{.ModelName}}Event(id string, data *{{.ModelName}}) *{{.ModelName}}Event {
	return &{{.ModelName}}Event{
		ID:   id,
		Meta: make(map[string]string),
		Body: data,
	}
}

// {{.ModelName}}Handler интерфейс обработчика сообщения
type {{.ModelName}}Handler interface {
	Handle(ctx context.Context, event *{{.ModelName}}Event) error
}

// {{.ModelName}}HandlerFunc тип-функция, реализующий интефейс {{.ModelName}}Handler
type {{.ModelName}}HandlerFunc func(ctx context.Context, event *{{.ModelName}}Event) error

// Handle обработчик событий.
func (fn {{.ModelName}}HandlerFunc) Handle(ctx context.Context, event *{{.ModelName}}Event) error {
	return fn(ctx, event)
}

// Make{{.ModelName}}Handler конструктор метода для обработки входящих сообщений типа {{.ModelName}}Event
// По умолчанию для обработки ошибок используется стратегия "записать в сентри и пропустить"
// В данном случае это ошибки парсинга id и тела сообщения. Если ID не представляет собой UUID, или тело соообщения
// не является JSON-ом - такое сообщение будет пропущено, а запись об инциденте появится в Sentry. Таким образом
// не произойдет залипания очереди на некорректном сообщении. Если же необходимо кастомное поведение - разработчик
// может определить свой handler и обработать ошибки в соответствии с собственными нуждами.
func Make{{.ModelName}}Handler(handler {{.ModelName}}Handler) message.NoPublishHandlerFunc {
	return func(msg *message.Message) error {
		r := new({{.ModelName}})

		if err := protojson.Unmarshal(msg.Payload, r); err != nil {
			log.Err(err).Msg("невозможно десериализовать данные сообщения")

			return nil
		}

		evt := &{{.ModelName}}Event{
			ID:   msg.UUID,
			Meta: msg.Metadata,
			Body: r,
		}

		if err := handler.Handle(msg.Context(), evt); err != nil {
        	return errors.Wrap(err, "не удалось обработать событие")
        }

        return nil
	}
}

// {{.ModelName}}Publisher интерфейс для отправки сообщений типа {{.ModelName}}Event в очередь
type {{.ModelName}}Publisher interface {
	Publish(event *{{.ModelName}}Event) error
}

type {{.ModelNamePrivate}}Publisher struct {
	topic string
	mp    message.Publisher
}

func (r *{{.ModelNamePrivate}}Publisher) Publish(event *{{.ModelName}}Event) error {
	marhal := protojson.MarshalOptions{
		EmitUnpopulated: true,
	}

	payload, err := marhal.Marshal(event.Body)
	if err != nil {
		return errors.Wrap(err, "невозможно сериализовать данные")
	}

	msg := message.NewMessage(event.ID, payload)

	if event.Meta == nil {
 		event.Meta = map[string]string{}
 	}

	msg.Metadata = event.Meta

	if err = r.mp.Publish(r.topic, msg); err != nil {
		return errors.Wrap(err, "не удалось отправить сообщение")
	}

	return nil
}

// Make{{.ModelName}}Publisher конструктор для паблишера сообщений типа {{.ModelName}}Event
func Make{{.ModelName}}Publisher(topic string, p message.Publisher) {{.ModelName}}Publisher {
	return &{{.ModelNamePrivate}}Publisher{
		topic: topic,
		mp:    p,
	}
}

