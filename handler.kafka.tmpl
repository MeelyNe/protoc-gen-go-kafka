// Code generated by protoc-gen-go. DO NOT EDIT.
//
// versions:
//     protoc-gen-go v1.27.1
//     protoc        (unknown)
// source: {{.PathFile}}

package {{ .PackageName }}

import (
	"context"

	"github.com/ThreeDotsLabs/watermill/message"
	"github.com/google/uuid"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
	"google.golang.org/protobuf/encoding/protojson"
)

// {{.ModelName}}MessageEvent структурая, содержащая поля сообщения
type {{.ModelName}}MessageEvent struct {
	ID   uuid.UUID
	Meta map[string]string
	Body *{{.ModelName}}
}

// New{{.ModelName}}MessageEvent конструктор события {{.ModelName}}MessageEvent
func New{{.ModelName}}MessageEvent(data *{{.ModelName}}) *{{.ModelName}}MessageEvent {
	return &{{.ModelName}}MessageEvent{
		ID:   uuid.New(),
		Meta: make(map[string]string),
		Body: data,
	}
}

// {{.ModelName}}MessageHandler интерфейс обработчика сообщения
type {{.ModelName}}MessageHandler interface {
	Handle(ctx context.Context, event *{{.ModelName}}MessageEvent) error
}

// {{.ModelName}}MessageHandlerFunc тип-функция, реализующий интефейс {{.ModelName}}MessageHandler
type {{.ModelName}}MessageHandlerFunc func(ctx context.Context, event *{{.ModelName}}MessageEvent) error

// Handle обработчик событий.
func (fn {{.ModelName}}MessageHandlerFunc) Handle(ctx context.Context, event *{{.ModelName}}MessageEvent) error {
	return fn(ctx, event)
}

// Make{{.ModelName}}MessageHandler конструктор метода для обработки входящих сообщений типа {{.ModelName}}MessageEvent
// По умолчанию для обработки ошибок используется стратегия "записать в сентри и пропустить"
// В данном случае это ошибки парсинга id и тела сообщения. Если ID не представляет собой UUID, или тело соообщения
// не является JSON-ом - такое сообщение будет пропущено, а запись об инциденте появится в Sentry. Таким образом
// не произойдет залипания очереди на некорректном сообщении. Если же необходимо кастомное поведение - разработчик
// может определить свой handler и обработать ошибки в соответствии с собственными нуждами.
func Make{{.ModelName}}MessageHandler(handler {{.ModelName}}MessageHandler) message.NoPublishHandlerFunc {
	return func(msg *message.Message) error {
		r := new({{.ModelName}})

		if err := protojson.Unmarshal(msg.Payload, r); err != nil {
			log.Err(err).Msg("невозможно десериализовать данные сообщения")

			return nil
		}

		id, err := uuid.Parse(msg.UUID)
		if err != nil {
			log.Err(err).Msg("невозможно разобрать идентификатор сообщения")

			return nil
		}

		evt := &{{.ModelName}}MessageEvent{
			ID:   id,
			Meta: msg.Metadata,
			Body: r,
		}

		if err = handler.Handle(msg.Context(), evt); err != nil {
        	return errors.Wrap(err, "не удалось обработать событие")
        }

        return nil
	}
}

// {{.ModelName}}MessagePublisher интерфейс для отправки сообщений типа {{.ModelName}}MessageEvent в очередь
type {{.ModelName}}MessagePublisher interface {
	Publish(event *{{.ModelName}}MessageEvent) error
}

type outgoing{{.ModelName}}Publisher struct {
	topic string
	mp    message.Publisher
}

func (r *outgoing{{.ModelName}}Publisher) Publish(event *{{.ModelName}}MessageEvent) error {
	payload, err := protojson.Marshal(event.Body)
	if err != nil {
		return errors.Wrap(err, "невозможно сериализовать данные")
	}

	msg := message.NewMessage(event.ID.String(), payload)
	msg.Metadata = event.Meta

	if err = r.mp.Publish(r.topic, msg); err != nil {
		return errors.Wrap(err, "не удалось отправить сообщение")
	}

	return nil
}

// Make{{.ModelName}}MessagePublisher конструктор для паблишера сообщений типа {{.ModelName}}MessageEvent
func Make{{.ModelName}}MessagePublisher(topic string, p message.Publisher) {{.ModelName}}MessagePublisher {
	return &outgoing{{.ModelName}}Publisher{
		topic: topic,
		mp:    p,
	}
}

